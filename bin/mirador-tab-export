#!/usr/bin/env python3
"""Export verified guitar tabs to PDF via Jinja2 + LaTeX.

Usage:
    mirador-tab-export reference Am-pentatonic              # 5 positions PDF
    mirador-tab-export reference --all-keys minor-pentatonic  # 12 keys x 5 positions
    mirador-tab-export exercises Am-pentatonic --position 1   # all 8 exercise types
    mirador-tab-export exercises Am-pentatonic --position all  # all positions
    mirador-tab-export book minor-pentatonic                  # complete 12-key book
    mirador-tab-export book minor-pentatonic --key A          # single key book
    mirador-tab-export reference Am-pentatonic --output /path/to/file.pdf
"""

import importlib.util
import os
import subprocess
import sys
import tempfile

# Import tab generator (no .py extension, use SourceFileLoader)
import importlib.machinery
_tab_gen_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'mirador-tab-generator')
_loader = importlib.machinery.SourceFileLoader('mirador_tab_generator', _tab_gen_path)
_spec = importlib.util.spec_from_loader('mirador_tab_generator', _loader)
tab_gen = importlib.util.module_from_spec(_spec)
_spec.loader.exec_module(tab_gen)

from jinja2 import Environment, FileSystemLoader

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
TEMPLATE_DIR = os.path.join(SCRIPT_DIR, '..', 'templates')
EXPORT_DIR = os.path.expanduser('~/.mirador/exports')
PDFLATEX = '/Library/TeX/texbin/pdflatex'

# Max note columns per tab line before wrapping to a new line.
# At \small monospace: landscape ~140 chars usable, portrait ~105 chars usable.
# 24 cols = ~103 chars (portrait), 32 cols = ~135 chars (landscape).
MAX_COLS_LANDSCAPE = 32
MAX_COLS_PORTRAIT = 24


def ensure_dirs():
    os.makedirs(EXPORT_DIR, exist_ok=True)


def render_template(template_name, context):
    """Render a Jinja2 template with LaTeX-safe delimiters."""
    env = Environment(
        loader=FileSystemLoader(TEMPLATE_DIR),
        block_start_string='<%',
        block_end_string='%>',
        variable_start_string='<<',
        variable_end_string='>>',
        comment_start_string='<#',
        comment_end_string='#>',
    )
    template = env.get_template(template_name)
    return template.render(**context)


def compile_pdf(tex_content, output_path, runs=1, timeout=60):
    """Write .tex to temp dir, compile with pdflatex, move PDF to output.

    runs: number of pdflatex passes (2 needed for TOC/hyperref).
    timeout: seconds per pdflatex run.
    """
    import shutil
    with tempfile.TemporaryDirectory() as tmpdir:
        tex_path = os.path.join(tmpdir, 'output.tex')
        with open(tex_path, 'w') as f:
            f.write(tex_content)

        for i in range(runs):
            result = subprocess.run(
                [PDFLATEX, '-interaction=nonstopmode', '-output-directory', tmpdir, tex_path],
                capture_output=True, text=True, timeout=timeout
            )

        pdf_path = os.path.join(tmpdir, 'output.pdf')
        if not os.path.exists(pdf_path):
            print("LaTeX compilation failed:")
            print(result.stdout[-2000:] if len(result.stdout) > 2000 else result.stdout)
            sys.exit(1)

        os.makedirs(os.path.dirname(output_path) or '.', exist_ok=True)
        shutil.move(pdf_path, output_path)

    print(f"PDF: {output_path}")
    return output_path


def escape_latex(text):
    """Escape special LaTeX characters in text (not in verbatim blocks)."""
    replacements = [
        ('\\', '\\textbackslash{}'),
        ('#', '\\#'),
        ('$', '\\$'),
        ('%', '\\%'),
        ('&', '\\&'),
        ('_', '\\_'),
        ('{', '\\{'),
        ('}', '\\}'),
        ('~', '\\textasciitilde{}'),
        ('^', '\\textasciicircum{}'),
    ]
    for old, new in replacements:
        text = text.replace(old, new)
    return text


def build_reference(root, scale_type, all_keys=False, output=None):
    """Build reference sheet PDF."""
    if all_keys:
        roots = tab_gen.ALL_ROOTS
        dr_label = scale_type.replace('-', ' ').title()
        title = f"All 12 Keys -- {dr_label}"
        default_name = f"all_keys_{scale_type}_reference.pdf"
    else:
        roots = [root]
        dr = tab_gen.display_root(root)
        dr_label = scale_type.replace('-', ' ').title()
        title = f"{dr} {dr_label}"
        default_name = f"{dr}_{scale_type}_reference.pdf".replace(' ', '_')

    positions_data = []
    for r in roots:
        dr = tab_gen.display_root(r)
        notes = tab_gen.get_scale_notes(r, scale_type)
        display_notes = [tab_gen.display_note(n, r) for n in notes]
        degree_names = tab_gen.SCALE_DEGREE_NAMES.get(scale_type, [])
        positions = tab_gen.get_scale_positions(r, scale_type)

        for pos in positions:
            fmin, fmax = pos['fret_range']
            tab_text = tab_gen.render_tab_sequential(pos, r, max_cols=MAX_COLS_LANDSCAPE)
            # Note legend
            parts = []
            for s in range(6):
                label = tab_gen.TUNING_LABELS[s]
                for n in pos['strings'][s]:
                    parts.append(f"{label}:{n['fret']}={tab_gen.display_note(n['note'], r)}")
            note_legend = ' | '.join(parts)

            key_label = f"{dr} {dr_label} -- " if all_keys else ""
            positions_data.append({
                'number': f"{key_label}Position {pos['position']}",
                'fret_range': f"{fmin}-{fmax}",
                'tab': tab_text,
                'notes': escape_latex(note_legend),
            })

    scale_notes = tab_gen.get_scale_notes(roots[0], scale_type)
    display_notes = [tab_gen.display_note(n, roots[0]) for n in scale_notes]
    degree_names = tab_gen.SCALE_DEGREE_NAMES.get(scale_type, [])
    info_parts = [f"Notes: {', '.join(display_notes)}"]
    if degree_names:
        info_parts.append(f"Degrees: {', '.join(degree_names)}")

    context = {
        'title': escape_latex(title),
        'scale_info': escape_latex(' | '.join(info_parts)) if not all_keys else escape_latex(f"{len(roots)} keys x 5 positions = {len(positions_data)} patterns"),
        'positions': positions_data,
    }

    tex = render_template('scale_reference.tex.j2', context)
    output_path = output or os.path.join(EXPORT_DIR, default_name)
    return compile_pdf(tex, output_path)


def build_exercises(root, scale_type, pos_num='1', output=None):
    """Build exercise sheet PDF."""
    dr = tab_gen.display_root(root)
    dr_label = scale_type.replace('-', ' ').title()
    positions = tab_gen.get_scale_positions(root, scale_type)

    if pos_num == 'all':
        pos_list = positions
        title = f"{dr} {dr_label} -- All Positions Exercises"
        default_name = f"{dr}_{scale_type}_all_exercises.pdf".replace(' ', '_')
    else:
        idx = int(pos_num) - 1
        if idx < 0 or idx >= len(positions):
            print(f"Position {pos_num} not found (1-{len(positions)})")
            sys.exit(1)
        pos_list = [positions[idx]]
        title = f"{dr} {dr_label} -- Position {pos_num} Exercises"
        default_name = f"{dr}_{scale_type}_pos{pos_num}_exercises.pdf".replace(' ', '_')

    exercises_data = []
    for pos in pos_list:
        for etype in tab_gen.EXERCISE_TYPES:
            gen_fn = tab_gen.EXERCISE_TYPES[etype]
            name, events = gen_fn(pos)
            tab_text = tab_gen.render_exercise_tab(events, max_cols=MAX_COLS_PORTRAIT)
            pos_label = f"Position {pos['position']} -- " if pos_num == 'all' else ""
            exercises_data.append({
                'name': escape_latex(f"{pos_label}{name}"),
                'tab': tab_text,
            })

    notes = tab_gen.get_scale_notes(root, scale_type)
    display_notes = [tab_gen.display_note(n, root) for n in notes]
    info = f"Notes: {', '.join(display_notes)}"

    context = {
        'title': escape_latex(title),
        'scale_info': escape_latex(info),
        'exercises': exercises_data,
    }

    tex = render_template('exercises.tex.j2', context)
    output_path = output or os.path.join(EXPORT_DIR, default_name)
    return compile_pdf(tex, output_path)


# Key ordering: practical difficulty, not chromatic
KEY_ORDER_FOUNDATION = ['A', 'E', 'D', 'G', 'C', 'B']
KEY_ORDER_SHARPS_FLATS = ['F#', 'A#', 'D#', 'G#', 'C#', 'F']


def build_book(scale_type, single_key=None, output=None):
    """Build a complete reference book PDF for a scale type."""
    dr_label = scale_type.replace('-', ' ').title()

    if single_key:
        # Resolve enharmonics
        reverse_enharmonic = {v: k for k, v in tab_gen.ENHARMONIC.items()}
        internal = reverse_enharmonic.get(single_key, single_key)
        all_keys = [internal]
        part_groups = [("", all_keys)]
        title = f"{tab_gen.display_root(internal)} {dr_label}"
        default_name = f"{scale_type}_{tab_gen.display_root(internal)}_book.pdf"
    else:
        all_keys = KEY_ORDER_FOUNDATION + KEY_ORDER_SHARPS_FLATS
        part_groups = [
            ("Foundation Keys", KEY_ORDER_FOUNDATION),
            ("Sharp and Flat Keys", KEY_ORDER_SHARPS_FLATS),
        ]
        title = dr_label
        default_name = f"{scale_type}_complete_book.pdf"

    # Descriptions for part divider pages
    part_descriptions = {
        "Foundation Keys": "The keys every guitarist learns first. Open chord shapes are abundant, fret positions sit in the comfortable 0--8 range, and most popular songs live here. Master these six keys and you can play over the vast majority of rock, blues, and pop music.",
        "Sharp and Flat Keys": "Keys that require barre chords and less intuitive positions. These keys unlock the full fretboard and prepare you for any musical situation -- jazz standards, horn-section keys, and modulating progressions.",
    }

    # Exercise type descriptions for educational context
    exercise_descriptions = {
        'ascending': "Build fretboard familiarity by running the full position from low to high.",
        'descending': "Reverse the pattern to develop equal fluency in both directions.",
        'legato': "Develop hammer-on and pull-off technique for smooth, connected phrasing.",
        'sequence3': "Train your ear and fingers to break out of linear scale runs into musical patterns.",
        'sequence4': "Expand sequencing to four-note groups for more complex melodic vocabulary.",
        'string-skip': "Build accuracy jumping across wide intervals -- essential for modern lead playing.",
        'alternate': "Develop consistent down-up pick attack and rhythmic precision at any tempo.",
        'triplet': "Internalize triplet grouping to add rhythmic variety and swing feel to your lines.",
    }

    # Scale description for cover page
    scale_descriptions = {
        'minor-pentatonic': "The minor pentatonic scale is the single most important scale in rock, blues, and popular music. Five notes, five positions, infinite possibilities. This resource provides every position in every key with mathematically verified tablature, companion chords to play over, and eight exercise types designed to build real fretboard fluency -- not just memorization.",
        'blues': "The blues scale adds one chromatic passing tone to the minor pentatonic, creating the tension and release that defines the blues. This resource covers every position in every key with verified tablature and targeted exercises.",
        'major-pentatonic': "The major pentatonic scale is the bright, uplifting counterpart to the minor pentatonic. Essential for country, pop, and major-key soloing. Every position, every key, verified and exercise-ready.",
    }
    scale_desc = scale_descriptions.get(scale_type,
        f"Complete {dr_label} reference with verified tablature across all 12 keys, 5 positions per key, companion chords, and 8 exercise types per position.")

    parts = []
    total_keys = 0
    for part_title, keys in part_groups:
        chapters = []
        for root in keys:
            dr = tab_gen.display_root(root)
            key_name = f"{dr} {dr_label}"
            notes = tab_gen.get_scale_notes(root, scale_type)
            display_notes = [tab_gen.display_note(n, root) for n in notes]
            degree_names = tab_gen.SCALE_DEGREE_NAMES.get(scale_type, [])
            info_parts = [f"Notes: {', '.join(display_notes)}"]
            if degree_names:
                info_parts.append(f"Degrees: {', '.join(degree_names)}")

            # Scale positions
            positions = tab_gen.get_scale_positions(root, scale_type)
            pos_data = []
            for pos in positions:
                fmin, fmax = pos['fret_range']
                tab_text = tab_gen.render_tab_sequential(pos, root, max_cols=MAX_COLS_PORTRAIT)
                note_parts = []
                for s in range(6):
                    label = tab_gen.TUNING_LABELS[s]
                    for n in pos['strings'][s]:
                        note_parts.append(f"{label}:{n['fret']}={tab_gen.display_note(n['note'], root)}")
                pos_data.append({
                    'number': pos['position'],
                    'fret_range': f"{fmin}-{fmax}",
                    'tab': tab_text,
                    'notes': escape_latex(' | '.join(note_parts)),
                })

            # Companion chords
            chords = tab_gen.get_companion_chords(root, scale_type)
            chords_tab = tab_gen.render_chord_tab(chords)
            progression = ' - '.join(name for name, _ in chords)

            # Exercises per position
            exercise_groups = []
            for pos in positions:
                ex_list = []
                for etype in tab_gen.EXERCISE_TYPES:
                    gen_fn = tab_gen.EXERCISE_TYPES[etype]
                    name, events = gen_fn(pos)
                    tab_text = tab_gen.render_exercise_tab(events, max_cols=MAX_COLS_PORTRAIT)
                    ex_list.append({
                        'name': escape_latex(name),
                        'tab': tab_text,
                        'description': escape_latex(exercise_descriptions.get(etype, '')),
                    })
                exercise_groups.append({
                    'number': pos['position'],
                    'exercises': ex_list,
                })

            chapters.append({
                'title': escape_latex(key_name),
                'key_name': escape_latex(key_name),
                'info': escape_latex(' | '.join(info_parts)),
                'positions': pos_data,
                'chords_tab': chords_tab,
                'progression': escape_latex(progression),
                'exercise_groups': exercise_groups,
            })
            total_keys += 1
            print(f"  [{total_keys}/12] {key_name}")

        key_names = [escape_latex(f"{tab_gen.display_root(r)} {dr_label}") for r in keys]
        parts.append({
            'title': escape_latex(part_title),
            'description': escape_latex(part_descriptions.get(part_title, '')),
            'key_list': ', '.join(key_names),
            'chapters': chapters,
        })

    # Compute stats for cover page
    num_keys = total_keys
    num_positions = 5
    num_exercise_types = len(tab_gen.EXERCISE_TYPES)
    # Sample first chapter for chord count
    sample_chords = tab_gen.get_companion_chords(all_keys[0], scale_type)
    num_chords = len(sample_chords)
    total_exercises = num_keys * num_positions * num_exercise_types
    total_tabs = num_keys * (num_positions + num_chords + num_positions * num_exercise_types)

    context = {
        'title': escape_latex(title),
        'scale_description': escape_latex(scale_desc),
        'parts': parts,
        'num_keys': num_keys,
        'num_positions': num_positions,
        'num_chords': num_chords,
        'num_exercise_types': num_exercise_types,
        'total_exercises': total_exercises,
        'total_tabs': total_tabs,
        'exercise_descriptions': {k: escape_latex(v) for k, v in exercise_descriptions.items()},
    }

    print("Rendering LaTeX...")
    tex = render_template('complete_book.tex.j2', context)
    output_path = output or os.path.join(EXPORT_DIR, default_name)
    print("Compiling PDF (2 passes for TOC)...")
    return compile_pdf(tex, output_path, runs=2, timeout=120)


def main():
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(0)

    ensure_dirs()
    cmd = sys.argv[1]

    # Parse common flags
    output = None
    all_keys = False
    pos_num = '1'
    for i, arg in enumerate(sys.argv):
        if arg == '--output' and i + 1 < len(sys.argv):
            output = sys.argv[i + 1]
        if arg == '--all-keys':
            all_keys = True
        if arg == '--position' and i + 1 < len(sys.argv):
            pos_num = sys.argv[i + 1]

    if cmd == 'reference':
        if all_keys:
            # Find scale type arg (not a flag)
            scale_type = 'minor-pentatonic'
            for a in sys.argv[2:]:
                if not a.startswith('--') and a in tab_gen.SCALE_FORMULAS:
                    scale_type = a
                    break
            build_reference(None, scale_type, all_keys=True, output=output)
        else:
            if len(sys.argv) < 3:
                print("Usage: mirador-tab-export reference Am-pentatonic")
                sys.exit(1)
            scale_arg = sys.argv[2]
            root, scale_type = tab_gen.parse_scale_arg(scale_arg)
            build_reference(root, scale_type, output=output)

    elif cmd == 'exercises':
        if len(sys.argv) < 3:
            print("Usage: mirador-tab-export exercises Am-pentatonic --position 1")
            sys.exit(1)
        scale_arg = sys.argv[2]
        root, scale_type = tab_gen.parse_scale_arg(scale_arg)
        build_exercises(root, scale_type, pos_num, output=output)

    elif cmd == 'book':
        # Find scale type (positional arg, not a flag)
        scale_type = 'minor-pentatonic'
        for a in sys.argv[2:]:
            if not a.startswith('--') and a in tab_gen.SCALE_FORMULAS:
                scale_type = a
                break
            # Also accept scale args like Am-pentatonic
            if not a.startswith('--') and '-' in a:
                try:
                    _, st = tab_gen.parse_scale_arg(a)
                    if st in tab_gen.SCALE_FORMULAS:
                        scale_type = st
                        break
                except SystemExit:
                    pass

        # Parse --key flag for single-key builds
        single_key = None
        for i, arg in enumerate(sys.argv):
            if arg == '--key' and i + 1 < len(sys.argv):
                single_key = sys.argv[i + 1]

        build_book(scale_type, single_key=single_key, output=output)

    else:
        print(f"Unknown command: {cmd}")
        print(__doc__)
        sys.exit(1)


if __name__ == '__main__':
    main()
