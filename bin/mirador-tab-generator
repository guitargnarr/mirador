#!/usr/bin/env python3
"""Generate verified ASCII guitar tablature from scale/chord definitions.

Uses a complete fretboard note map to produce accurate tabs that can be
paired with LLM-generated theory explanations and exercises.

Usage:
    mirador-tab-generator scale Am-pentatonic [--position 1-5|all]
    mirador-tab-generator scale Em-pentatonic --position 3
    mirador-tab-generator all-keys [minor-pentatonic|blues|major-pentatonic]
    mirador-tab-generator exercise Am-pentatonic --position 1 --type legato
    mirador-tab-generator fretboard A  # show all A notes on fretboard
"""

import sys

# Complete chromatic note sequence (sharps internally)
CHROMATIC = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']

# Enharmonic equivalents for display
ENHARMONIC = {
    'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb',
}

# Keys whose minor pentatonic scales use flats (Bb not A#, Eb not D#, etc.)
FLAT_KEYS = {'C', 'F', 'G', 'Bb', 'Eb', 'Ab', 'Db', 'Gb',
             'D#', 'G#', 'A#', 'C#'}
SHARP_KEYS = {'D', 'A', 'E', 'B', 'F#'}

# Standard tuning open string notes
TUNING = ['E', 'A', 'D', 'G', 'B', 'E']  # low to high
TUNING_LABELS = ['E', 'A', 'D', 'G', 'B', 'e']  # display labels

# Scale formulas (intervals in semitones from root)
SCALE_FORMULAS = {
    'minor-pentatonic': [0, 3, 5, 7, 10],
    'major-pentatonic': [0, 2, 4, 7, 9],
    'natural-minor':    [0, 2, 3, 5, 7, 8, 10],
    'natural-major':    [0, 2, 4, 5, 7, 9, 11],
    'blues':            [0, 3, 5, 6, 7, 10],
    'dorian':           [0, 2, 3, 5, 7, 9, 10],
    'mixolydian':       [0, 2, 4, 5, 7, 9, 10],
    'harmonic-minor':   [0, 2, 3, 5, 7, 8, 11],
}

SCALE_DEGREE_NAMES = {
    'minor-pentatonic': ['1', 'b3', '4', '5', 'b7'],
    'major-pentatonic': ['1', '2', '3', '5', '6'],
    'blues':            ['1', 'b3', '4', 'b5', '5', 'b7'],
    'natural-minor':    ['1', '2', 'b3', '4', '5', 'b6', 'b7'],
    'natural-major':    ['1', '2', '3', '4', '5', '6', '7'],
    'dorian':           ['1', '2', 'b3', '4', '5', '6', 'b7'],
    'mixolydian':       ['1', '2', '3', '4', '5', '6', 'b7'],
    'harmonic-minor':   ['1', '2', 'b3', '4', '5', 'b6', '7'],
}

# Chord formulas
CHORD_FORMULAS = {
    'major':  [0, 4, 7],
    'minor':  [0, 3, 7],
    'dom7':   [0, 4, 7, 10],
    'min7':   [0, 3, 7, 10],
    'maj7':   [0, 4, 7, 11],
    'dim':    [0, 3, 6],
    'aug':    [0, 4, 8],
    'sus2':   [0, 2, 7],
    'sus4':   [0, 5, 7],
    'power':  [0, 7],
}

ALL_ROOTS = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']


def display_note(note, root='C'):
    """Return the display name for a note, using flats or sharps based on key context."""
    if '#' not in note:
        return note
    if root in FLAT_KEYS or root in ENHARMONIC.values():
        return ENHARMONIC.get(note, note)
    return note


def display_root(root):
    """Return the conventional display name for a root note."""
    flat_display = {
        'C#': 'Db', 'D#': 'Eb', 'G#': 'Ab', 'A#': 'Bb',
    }
    return flat_display.get(root, root)


def note_at_fret(string_idx, fret):
    """Return the note name at a given string and fret."""
    open_note = TUNING[string_idx]
    open_idx = CHROMATIC.index(open_note)
    return CHROMATIC[(open_idx + fret) % 12]


def fret_for_note(string_idx, note, min_fret=0, max_fret=24):
    """Return all frets on a string where the given note appears."""
    open_note = TUNING[string_idx]
    open_idx = CHROMATIC.index(open_note)
    note_idx = CHROMATIC.index(note)
    frets = []
    for f in range(min_fret, max_fret + 1):
        if (open_idx + f) % 12 == note_idx:
            frets.append(f)
    return frets


def get_scale_notes(root, scale_type):
    """Return list of note names for a scale (internal sharp names)."""
    formula = SCALE_FORMULAS[scale_type]
    root_idx = CHROMATIC.index(root)
    return [CHROMATIC[(root_idx + interval) % 12] for interval in formula]


def _build_position(notes, anchor, pos_num, notes_per_string=2):
    """Build a single position from an anchor fret on the low E string."""
    pos_data = {'position': pos_num, 'strings': []}
    pos_min = 24
    pos_max = 0
    for s in range(6):
        string_notes = []
        for note in notes:
            for f in fret_for_note(s, note, max(0, anchor - 1), anchor + 4):
                string_notes.append({'fret': f, 'note': note})
        string_notes.sort(key=lambda x: x['fret'])
        seen = set()
        unique = []
        for sn in string_notes:
            if sn['fret'] not in seen:
                seen.add(sn['fret'])
                unique.append(sn)
        # Enforce notes-per-string limit
        picked = unique[:notes_per_string]
        pos_data['strings'].append(picked)
        for p in picked:
            pos_min = min(pos_min, p['fret'])
            pos_max = max(pos_max, p['fret'])
    pos_data['fret_range'] = (pos_min, pos_max)
    return pos_data


def get_scale_positions(root, scale_type='minor-pentatonic'):
    """Compute all 5 positions for any scale type.

    Pentatonic/blues: 2 notes per string (standard CAGED positions).
    7-note scales: 2-3 notes per string (3-note-per-string patterns).

    Returns list of position dicts, each with:
      - position: 1-5
      - strings: list of 6 lists, each containing {'fret': int, 'note': str} dicts
      - fret_range: (min_fret, max_fret)
    """
    notes = get_scale_notes(root, scale_type)
    num_scale_notes = len(notes)
    # Pentatonic (5) and blues (6) use 2 notes per string
    # 7-note scales use 3 notes per string
    nps = 2 if num_scale_notes <= 6 else 3
    positions = []

    root_frets_e = fret_for_note(0, root, 0, 15)
    start_fret = root_frets_e[0]

    for pos_num in range(5):
        if pos_num == 0:
            anchor = start_fret
        else:
            prev_low = positions[pos_num - 1]['strings'][0][0]['fret']
            candidates = []
            for note in notes:
                for f in fret_for_note(0, note, prev_low + 1, prev_low + 7):
                    candidates.append(f)
            candidates.sort()
            if not candidates:
                break
            anchor = candidates[0]

        pos_data = _build_position(notes, anchor, pos_num + 1, nps)

        # Dedupe: if identical frets to previous position, advance anchor
        if positions:
            prev = positions[-1]
            same = all(
                [n['fret'] for n in prev['strings'][s]] == [n['fret'] for n in pos_data['strings'][s]]
                for s in range(6)
            )
            if same:
                candidates2 = []
                for note in notes:
                    for f in fret_for_note(0, note, anchor + 1, anchor + 8):
                        candidates2.append(f)
                candidates2.sort()
                if candidates2:
                    anchor = candidates2[0]
                    pos_data = _build_position(notes, anchor, pos_num + 1, nps)

        positions.append(pos_data)

    return positions


def render_tab_sequential(pos_data, root='C'):
    """Render tab as an ascending scale run - notes play left to right, one string at a time.

    This is how you actually play a scale: low E first, then A, D, G, B, e.
    Each string's notes appear at the correct horizontal position in the sequence.
    """
    # Build the sequential note list: string 0 notes, string 1 notes, etc.
    all_events = []  # list of (string_idx, fret, note)
    for s in range(6):
        for n in pos_data['strings'][s]:
            all_events.append((s, n['fret'], n['note']))

    total_notes = len(all_events)
    if total_notes == 0:
        return ""

    # Each column is one note in the sequence
    # Column width: 4 chars per note slot (enough for "--XX" where XX is up to 2 digits)
    col_width = 4

    # Build each string's line
    lines = {}
    for s in range(6):
        lines[s] = []

    for col_idx, (active_s, fret, note) in enumerate(all_events):
        fret_str = str(fret)
        for s in range(6):
            if s == active_s:
                # This string has a note in this column
                lines[s].append(fret_str.rjust(2))
            else:
                lines[s].append('--')

    output = []
    for s in reversed(range(6)):
        label = TUNING_LABELS[s]
        content = '--'.join(lines[s])
        output.append(f"  {label}|--{content}--|")

    return '\n'.join(output)


def render_position_full(pos_data, scale_notes, scale_type, root='C'):
    """Render a complete position with sequential tab + note info."""
    fmin, fmax = pos_data['fret_range']
    output = []
    output.append(f"Position {pos_data['position']} (frets {fmin}-{fmax})")

    output.append(render_tab_sequential(pos_data, root))

    # Note legend per string
    output.append("  Notes:")
    for s in range(6):
        label = TUNING_LABELS[s]
        notes = pos_data['strings'][s]
        if notes:
            note_info = ', '.join(
                f"{n['fret']}={display_note(n['note'], root)}" for n in notes
            )
            output.append(f"    {label}: {note_info}")

    degree_names = SCALE_DEGREE_NAMES.get(scale_type, [])
    if degree_names:
        output.append("  Degrees: " + ', '.join(
            f"{display_note(n, root)}({d})" for n, d in zip(scale_notes, degree_names)
        ))

    return '\n'.join(output)


def render_tab_compact(pos_data, root='C'):
    """Compact sequential tab for all-keys output."""
    return render_tab_sequential(pos_data, root)


def generate_legato_exercise(pos_data, bars=4):
    """Generate a legato exercise (hammer-ons/pull-offs) for a position."""
    output = []
    output.append(f"Legato Exercise - Position {pos_data['position']}")
    output.append("h = hammer-on, p = pull-off")

    # Build ascending then descending events
    asc_events = []  # (string_idx, text)
    for s in range(6):
        notes = pos_data['strings'][s]
        if len(notes) >= 2:
            asc_events.append((s, f"{notes[0]['fret']}h{notes[1]['fret']}"))
        elif len(notes) == 1:
            asc_events.append((s, str(notes[0]['fret'])))

    desc_events = []
    for s in reversed(range(6)):
        notes = pos_data['strings'][s]
        if len(notes) >= 2:
            desc_events.append((s, f"{notes[1]['fret']}p{notes[0]['fret']}"))
        elif len(notes) == 1:
            desc_events.append((s, str(notes[0]['fret'])))

    all_events = asc_events + [(-1, '|')] + desc_events
    col_width = max(len(ev[1]) for ev in all_events)

    lines = {s: [] for s in range(6)}
    for (active_s, text) in all_events:
        for s in range(6):
            if s == active_s:
                lines[s].append(text.center(col_width))
            elif active_s == -1:
                lines[s].append('|'.center(col_width))
            else:
                lines[s].append('-' * col_width)

    output_lines = []
    for s in reversed(range(6)):
        label = TUNING_LABELS[s]
        content = '-'.join(lines[s])
        output_lines.append(f"  {label}|--{content}--|")

    output.append('\n'.join(output_lines))
    return '\n'.join(output)


def show_note_on_fretboard(note, max_fret=15):
    """Show all occurrences of a note on the fretboard."""
    output = []
    dn = display_note(note)
    output.append(f"All {dn} notes on fretboard (frets 0-{max_fret}):")
    output.append("")

    header = "      " + "  ".join(f"{f:>2}" for f in range(max_fret + 1))
    output.append(header)
    output.append("      " + "---" * (max_fret + 1))

    for s in reversed(range(6)):
        label = TUNING_LABELS[s]
        frets = fret_for_note(s, note, 0, max_fret)
        line = f"  {label} | "
        for f in range(max_fret + 1):
            if f in frets:
                line += f" {dn:>2}"
            else:
                line += "  ."
        output.append(line)

    return '\n'.join(output)


def generate_all_keys(scale_type='minor-pentatonic'):
    """Generate all 5 positions for all 12 keys."""
    output = []
    output.append(f"{'=' * 70}")
    output.append(f"  ALL 12 KEYS - {scale_type.replace('-', ' ').title()}")
    output.append(f"  5 positions per key, 60 total patterns")
    output.append(f"{'=' * 70}")

    degree_names = SCALE_DEGREE_NAMES.get(scale_type, [])

    for root in ALL_ROOTS:
        dr = display_root(root)
        notes = get_scale_notes(root, scale_type)
        display_notes = [display_note(n, root) for n in notes]

        output.append("")
        output.append(f"{'─' * 70}")
        if scale_type == 'minor-pentatonic':
            output.append(f"  {dr} Minor Pentatonic")
        elif scale_type == 'major-pentatonic':
            output.append(f"  {dr} Major Pentatonic")
        elif scale_type == 'blues':
            output.append(f"  {dr} Blues")
        else:
            output.append(f"  {dr} {scale_type.replace('-', ' ').title()}")

        output.append(f"  Notes: {', '.join(display_notes)}")
        if degree_names:
            output.append(f"  Degrees: {', '.join(degree_names)}")
        output.append(f"{'─' * 70}")

        positions = get_scale_positions(root, scale_type)
        for pos in positions:
            fmin, fmax = pos['fret_range']
            output.append(f"\n  Position {pos['position']} (frets {fmin}-{fmax})")
            output.append(render_tab_compact(pos, root))

            # Note legend on one line
            parts = []
            for s in range(6):
                label = TUNING_LABELS[s]
                for n in pos['strings'][s]:
                    parts.append(f"{label}:{n['fret']}={display_note(n['note'], root)}")
            output.append(f"  {' | '.join(parts)}")

    output.append("")
    output.append(f"{'=' * 70}")
    output.append(f"  Generated {len(ALL_ROOTS)} keys x 5 positions = 60 patterns")
    output.append(f"{'=' * 70}")

    return '\n'.join(output)


def parse_scale_arg(arg):
    """Parse 'Am-pentatonic' into ('A', 'minor-pentatonic')."""
    arg = arg.strip()
    reverse_enharmonic = {v: k for k, v in ENHARMONIC.items()}

    for i, c in enumerate(arg):
        if c == 'm' and (i + 1 >= len(arg) or arg[i + 1] == '-'):
            root = arg[:i]
            root = reverse_enharmonic.get(root, root)
            if root not in CHROMATIC:
                print(f"Unknown root: {arg[:i]}. Use: {', '.join(CHROMATIC)}")
                sys.exit(1)
            rest = arg[i + 1:].lstrip('-')
            if not rest:
                rest = 'minor-pentatonic'
            elif rest == 'pentatonic':
                rest = 'minor-pentatonic'
            elif rest == 'blues':
                rest = 'blues'
            return root, rest

    if '-' in arg:
        parts = arg.split('-', 1)
        root = parts[0]
        root = reverse_enharmonic.get(root, root)
        scale = parts[1]
        if scale == 'pentatonic':
            scale = 'major-pentatonic'
        elif scale == 'major':
            scale = 'natural-major'
        elif scale == 'minor':
            scale = 'natural-minor'
        return root, scale

    return arg, 'minor-pentatonic'


def main():
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(0)

    cmd = sys.argv[1]

    if cmd == 'scale':
        if len(sys.argv) < 3:
            print("Usage: mirador-tab-generator scale Am-pentatonic [--position 1-5|all]")
            sys.exit(1)

        root, scale_type = parse_scale_arg(sys.argv[2])
        if scale_type not in SCALE_FORMULAS:
            print(f"Unknown scale type: {scale_type}")
            print(f"Available: {', '.join(SCALE_FORMULAS.keys())}")
            sys.exit(1)

        notes = get_scale_notes(root, scale_type)
        display_notes = [display_note(n, root) for n in notes]
        degree_names = SCALE_DEGREE_NAMES.get(scale_type, [])
        dr = display_root(root)

        position = 'all'
        for i, arg in enumerate(sys.argv):
            if arg == '--position' and i + 1 < len(sys.argv):
                position = sys.argv[i + 1]

        print(f"\n{dr} {scale_type.replace('-', ' ').title()}")
        print(f"Notes: {', '.join(display_notes)}")
        if degree_names:
            print(f"Degrees: {', '.join(degree_names)}")
        print()

        positions = get_scale_positions(root, scale_type)

        if position == 'all':
            for pos in positions:
                print(render_position_full(pos, notes, scale_type, root))
                print()
        else:
            pos_num = int(position)
            if 1 <= pos_num <= len(positions):
                print(render_position_full(positions[pos_num - 1], notes, scale_type, root))
            else:
                print(f"Position {pos_num} not found (1-{len(positions)})")

    elif cmd == 'all-keys':
        scale_type = 'minor-pentatonic'
        if len(sys.argv) >= 3:
            scale_type = sys.argv[2]
        if scale_type not in SCALE_FORMULAS:
            print(f"Unknown scale type: {scale_type}")
            print(f"Available: {', '.join(SCALE_FORMULAS.keys())}")
            sys.exit(1)
        print(generate_all_keys(scale_type))

    elif cmd == 'exercise':
        if len(sys.argv) < 3:
            print("Usage: mirador-tab-generator exercise Am-pentatonic --position 1 --type legato")
            sys.exit(1)

        root, scale_type = parse_scale_arg(sys.argv[2])
        positions = get_scale_positions(root, scale_type)

        pos_num = 1
        for i, arg in enumerate(sys.argv):
            if arg == '--position' and i + 1 < len(sys.argv):
                pos_num = int(sys.argv[i + 1])

        dr = display_root(root)
        if 1 <= pos_num <= len(positions):
            print(f"\n{dr} {scale_type.replace('-', ' ').title()} - Exercise")
            print()
            print(generate_legato_exercise(positions[pos_num - 1]))
        else:
            print(f"Position {pos_num} not found")

    elif cmd == 'fretboard':
        if len(sys.argv) < 3:
            print("Usage: mirador-tab-generator fretboard A")
            sys.exit(1)
        note = sys.argv[2]
        reverse_enharmonic = {v: k for k, v in ENHARMONIC.items()}
        note = reverse_enharmonic.get(note, note)
        if note not in CHROMATIC:
            print(f"Unknown note: {sys.argv[2]}. Use: {', '.join(CHROMATIC)}")
            sys.exit(1)
        print()
        print(show_note_on_fretboard(note))

    else:
        print(f"Unknown command: {cmd}")
        print(__doc__)
        sys.exit(1)

    print()


if __name__ == '__main__':
    main()
