#!/usr/bin/env python3
"""Generate verified ASCII guitar tablature from scale/chord definitions.

Uses a complete fretboard note map to produce accurate tabs that can be
paired with LLM-generated theory explanations and exercises.

Usage:
    mirador-tab-generator scale Am-pentatonic [--position 1-5|all]
    mirador-tab-generator scale Em-pentatonic --position 3
    mirador-tab-generator all-keys [minor-pentatonic|blues|major-pentatonic]
    mirador-tab-generator exercise Am-pentatonic --position 1 --type legato
    mirador-tab-generator chord Am7
    mirador-tab-generator fretboard A  # show all A notes on fretboard
"""

import sys

# Complete chromatic note sequence (sharps internally)
CHROMATIC = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']

# Enharmonic equivalents for display
ENHARMONIC = {
    'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb',
}

# Keys whose minor pentatonic scales use flats (Bb not A#, Eb not D#, etc.)
# G minor = G Bb C D F, C minor = C Eb F G Bb, F minor = F Ab Bb C Eb, etc.
FLAT_KEYS = {'C', 'F', 'G', 'Bb', 'Eb', 'Ab', 'Db', 'Gb',
             'D#', 'G#', 'A#', 'C#'}  # internal sharp names for flat keys
# Keys whose minor pentatonic scales use sharps: Bm (F#), F#m (C#), C#m (G#)
SHARP_KEYS = {'D', 'A', 'E', 'B', 'F#'}

# Standard tuning open string notes
TUNING = ['E', 'A', 'D', 'G', 'B', 'E']  # low to high
TUNING_LABELS = ['E', 'A', 'D', 'G', 'B', 'e']  # display labels

# Scale formulas (intervals in semitones from root)
SCALE_FORMULAS = {
    'minor-pentatonic': [0, 3, 5, 7, 10],       # 1 b3 4 5 b7
    'major-pentatonic': [0, 2, 4, 7, 9],         # 1 2 3 5 6
    'natural-minor':    [0, 2, 3, 5, 7, 8, 10],  # 1 2 b3 4 5 b6 b7
    'natural-major':    [0, 2, 4, 5, 7, 9, 11],  # 1 2 3 4 5 6 7
    'blues':            [0, 3, 5, 6, 7, 10],      # 1 b3 4 b5 5 b7
    'dorian':           [0, 2, 3, 5, 7, 9, 10],  # 1 2 b3 4 5 6 b7
    'mixolydian':       [0, 2, 4, 5, 7, 9, 10],  # 1 2 3 4 5 6 b7
    'harmonic-minor':   [0, 2, 3, 5, 7, 8, 11],  # 1 2 b3 4 5 b6 7
}

SCALE_DEGREE_NAMES = {
    'minor-pentatonic': ['1', 'b3', '4', '5', 'b7'],
    'major-pentatonic': ['1', '2', '3', '5', '6'],
    'blues':            ['1', 'b3', '4', 'b5', '5', 'b7'],
    'natural-minor':    ['1', '2', 'b3', '4', '5', 'b6', 'b7'],
    'natural-major':    ['1', '2', '3', '4', '5', '6', '7'],
    'dorian':           ['1', '2', 'b3', '4', '5', '6', 'b7'],
    'mixolydian':       ['1', '2', '3', '4', '5', '6', 'b7'],
    'harmonic-minor':   ['1', '2', 'b3', '4', '5', 'b6', '7'],
}

# Chord formulas (intervals in semitones from root)
CHORD_FORMULAS = {
    'major':  [0, 4, 7],
    'minor':  [0, 3, 7],
    'dom7':   [0, 4, 7, 10],
    'min7':   [0, 3, 7, 10],
    'maj7':   [0, 4, 7, 11],
    'dim':    [0, 3, 6],
    'aug':    [0, 4, 8],
    'sus2':   [0, 2, 7],
    'sus4':   [0, 5, 7],
    'power':  [0, 7],
}

# All 12 roots in conventional order for all-keys output
ALL_ROOTS = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']


def display_note(note, root='C'):
    """Return the display name for a note, using flats or sharps based on key context."""
    if '#' not in note:
        return note
    # Use flats for flat keys, sharps for sharp keys
    if root in FLAT_KEYS or root in ENHARMONIC.values():
        return ENHARMONIC.get(note, note)
    return note


def display_root(root):
    """Return the conventional display name for a root note."""
    # Map internal sharp names to flat equivalents where conventional
    # C# -> Db (Db minor is more readable than C# minor with all those flats)
    flat_display = {
        'C#': 'Db', 'D#': 'Eb', 'G#': 'Ab', 'A#': 'Bb',
    }
    return flat_display.get(root, root)


def note_at_fret(string_idx, fret):
    """Return the note name at a given string and fret."""
    open_note = TUNING[string_idx]
    open_idx = CHROMATIC.index(open_note)
    return CHROMATIC[(open_idx + fret) % 12]


def fret_for_note(string_idx, note, min_fret=0, max_fret=24):
    """Return all frets on a string where the given note appears."""
    open_note = TUNING[string_idx]
    open_idx = CHROMATIC.index(open_note)
    note_idx = CHROMATIC.index(note)
    frets = []
    for f in range(min_fret, max_fret + 1):
        if (open_idx + f) % 12 == note_idx:
            frets.append(f)
    return frets


def get_scale_notes(root, scale_type):
    """Return list of note names for a scale (internal sharp names)."""
    formula = SCALE_FORMULAS[scale_type]
    root_idx = CHROMATIC.index(root)
    return [CHROMATIC[(root_idx + interval) % 12] for interval in formula]


def get_pentatonic_positions(root, scale_type='minor-pentatonic'):
    """Compute all 5 pentatonic positions with 2 notes per string."""
    notes = get_scale_notes(root, scale_type)
    positions = []

    # Position 1 starts from the root on the low E string
    root_frets_e = fret_for_note(0, root, 0, 15)
    start_fret = root_frets_e[0]

    for pos_num in range(5):
        pos_data = {'position': pos_num + 1, 'strings': []}

        if pos_num == 0:
            anchor = start_fret
        else:
            prev_anchor = positions[pos_num - 1]['strings'][0][0]['fret']
            candidates = []
            for note in notes:
                for f in fret_for_note(0, note, prev_anchor + 1, prev_anchor + 6):
                    candidates.append(f)
            candidates.sort()
            anchor = candidates[0] if candidates else prev_anchor + 2

        min_fret = 24
        max_fret = 0
        for s in range(6):
            string_notes = []
            for note in notes:
                for f in fret_for_note(s, note, max(0, anchor - 1), anchor + 5):
                    string_notes.append({'fret': f, 'note': note})
            string_notes.sort(key=lambda x: x['fret'])
            seen = set()
            unique = []
            for sn in string_notes:
                if sn['fret'] not in seen:
                    seen.add(sn['fret'])
                    unique.append(sn)
            picked = unique[:2]
            pos_data['strings'].append(picked)
            for p in picked:
                min_fret = min(min_fret, p['fret'])
                max_fret = max(max_fret, p['fret'])

        pos_data['fret_range'] = (min_fret, max_fret)
        positions.append(pos_data)

    return positions


def render_position_full(pos_data, scale_notes, scale_type, root='C'):
    """Render a complete position with tab + note info."""
    fmin, fmax = pos_data['fret_range']
    output = []
    output.append(f"Position {pos_data['position']} (frets {fmin}-{fmax})")
    output.append("```")

    for s in reversed(range(6)):
        label = TUNING_LABELS[s]
        notes = pos_data['strings'][s]
        fret_strs = [str(n['fret']) for n in notes]
        content = '--'.join(f.rjust(2) for f in fret_strs)
        output.append(f"{label}|--{content}--|")

    output.append("```")

    output.append("Notes per string:")
    for s in range(6):
        label = TUNING_LABELS[s]
        notes = pos_data['strings'][s]
        note_info = ', '.join(
            f"fret {n['fret']}={display_note(n['note'], root)}" for n in notes
        )
        output.append(f"  {label}: {note_info}")

    degree_names = SCALE_DEGREE_NAMES.get(scale_type, [])
    if degree_names:
        output.append("Scale degrees: " + ', '.join(
            f"{display_note(n, root)}({d})" for n, d in zip(scale_notes, degree_names)
        ))

    return '\n'.join(output)


def render_position_compact(pos_data, root='C'):
    """Render a compact position with just the tab."""
    output = []
    for s in reversed(range(6)):
        label = TUNING_LABELS[s]
        notes = pos_data['strings'][s]
        fret_strs = [str(n['fret']) for n in notes]
        content = '--'.join(f.rjust(2) for f in fret_strs)
        output.append(f"{label}|--{content}--|")
    return '\n'.join(output)


def generate_legato_exercise(pos_data, bars=4):
    """Generate a legato exercise (hammer-ons/pull-offs) for a position."""
    output = []
    output.append(f"Legato Exercise - Position {pos_data['position']}")
    output.append("h = hammer-on, p = pull-off")
    output.append("```")

    tab = {s: [] for s in range(6)}
    # Ascending
    for active_s in range(6):
        for s in range(6):
            if s == active_s:
                notes = pos_data['strings'][s]
                if len(notes) >= 2:
                    tab[s].append(f"{notes[0]['fret']}h{notes[1]['fret']}")
                else:
                    tab[s].append(str(notes[0]['fret']))
            else:
                width = len(tab[active_s][-1]) if tab[active_s] else 3
                tab[s].append('-' * width)

    for s in range(6):
        tab[s].append('|')

    # Descending
    for active_s in reversed(range(6)):
        for s in range(6):
            if s == active_s:
                notes = pos_data['strings'][s]
                if len(notes) >= 2:
                    tab[s].append(f"{notes[1]['fret']}p{notes[0]['fret']}")
                else:
                    tab[s].append(str(notes[0]['fret']))
            else:
                width = len(tab[active_s][-1]) if tab[active_s] else 3
                tab[s].append('-' * width)

    for s in reversed(range(6)):
        label = TUNING_LABELS[s]
        content = '-'.join(tab[s])
        output.append(f"{label}|--{content}--|")

    output.append("```")
    return '\n'.join(output)


def show_note_on_fretboard(note, max_fret=15):
    """Show all occurrences of a note on the fretboard."""
    output = []
    dn = display_note(note)
    output.append(f"All {dn} notes on fretboard (frets 0-{max_fret}):")
    output.append("")

    header = "    " + "  ".join(f"{f:>2}" for f in range(max_fret + 1))
    output.append(header)
    output.append("    " + "---" * (max_fret + 1))

    for s in reversed(range(6)):
        label = TUNING_LABELS[s]
        frets = fret_for_note(s, note, 0, max_fret)
        line = f"{label} | "
        for f in range(max_fret + 1):
            if f in frets:
                line += f" {dn:>2}"
            else:
                line += "  ."
        output.append(line)

    return '\n'.join(output)


def generate_all_keys(scale_type='minor-pentatonic'):
    """Generate all 5 positions for all 12 keys."""
    output = []
    output.append(f"{'=' * 70}")
    output.append(f"  ALL 12 KEYS - {scale_type.replace('-', ' ').title()}")
    output.append(f"  5 positions per key, 60 total patterns")
    output.append(f"{'=' * 70}")

    degree_names = SCALE_DEGREE_NAMES.get(scale_type, [])

    for root in ALL_ROOTS:
        dr = display_root(root)
        notes = get_scale_notes(root, scale_type)
        display_notes = [display_note(n, root) for n in notes]

        output.append("")
        output.append(f"{'─' * 70}")
        if scale_type == 'minor-pentatonic':
            output.append(f"  {dr} Minor Pentatonic")
        elif scale_type == 'major-pentatonic':
            output.append(f"  {dr} Major Pentatonic")
        elif scale_type == 'blues':
            output.append(f"  {dr} Blues")
        else:
            output.append(f"  {dr} {scale_type.replace('-', ' ').title()}")

        output.append(f"  Notes: {', '.join(display_notes)}")
        if degree_names:
            output.append(f"  Degrees: {', '.join(degree_names)}")
        output.append(f"{'─' * 70}")

        positions = get_pentatonic_positions(root, scale_type)
        for pos in positions:
            fmin, fmax = pos['fret_range']
            output.append(f"\n  Position {pos['position']} (frets {fmin}-{fmax})")

            # Tab
            for s in reversed(range(6)):
                label = TUNING_LABELS[s]
                pnotes = pos['strings'][s]
                fret_strs = [str(n['fret']) for n in pnotes]
                content = '--'.join(f.rjust(2) for f in fret_strs)
                output.append(f"  {label}|--{content}--|")

            # Note details on one line
            parts = []
            for s in range(6):
                label = TUNING_LABELS[s]
                pnotes = pos['strings'][s]
                for n in pnotes:
                    parts.append(f"{label}:{n['fret']}={display_note(n['note'], root)}")
            output.append(f"  {' | '.join(parts)}")

    output.append("")
    output.append(f"{'=' * 70}")
    output.append(f"  Generated {len(ALL_ROOTS)} keys x 5 positions = 60 patterns")
    output.append(f"{'=' * 70}")

    return '\n'.join(output)


def parse_scale_arg(arg):
    """Parse 'Am-pentatonic' into ('A', 'minor-pentatonic')."""
    arg = arg.strip()

    # Handle flat input: Bbm, Ebm, etc.
    reverse_enharmonic = {v: k for k, v in ENHARMONIC.items()}

    # Check for shorthand: Am, Em, Gm, Bbm, Ebm etc.
    for i, c in enumerate(arg):
        if c == 'm' and (i + 1 >= len(arg) or arg[i + 1] == '-'):
            root = arg[:i]
            # Convert flat notation to internal sharp
            root = reverse_enharmonic.get(root, root)
            if root not in CHROMATIC:
                print(f"Unknown root: {arg[:i]}. Use: {', '.join(CHROMATIC)}")
                sys.exit(1)
            rest = arg[i + 1:].lstrip('-')
            if not rest:
                rest = 'minor-pentatonic'
            elif rest == 'pentatonic':
                rest = 'minor-pentatonic'
            elif rest == 'blues':
                rest = 'blues'
            return root, rest

    # Check for major shorthand or other scales
    if '-' in arg:
        parts = arg.split('-', 1)
        root = parts[0]
        root = reverse_enharmonic.get(root, root)
        scale = parts[1]
        if scale == 'pentatonic':
            scale = 'major-pentatonic'
        elif scale == 'major':
            scale = 'natural-major'
        elif scale == 'minor':
            scale = 'natural-minor'
        return root, scale

    return arg, 'minor-pentatonic'


def main():
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(0)

    cmd = sys.argv[1]

    if cmd == 'scale':
        if len(sys.argv) < 3:
            print("Usage: mirador-tab-generator scale Am-pentatonic [--position 1-5|all]")
            sys.exit(1)

        root, scale_type = parse_scale_arg(sys.argv[2])
        if scale_type not in SCALE_FORMULAS:
            print(f"Unknown scale type: {scale_type}")
            print(f"Available: {', '.join(SCALE_FORMULAS.keys())}")
            sys.exit(1)

        notes = get_scale_notes(root, scale_type)
        display_notes = [display_note(n, root) for n in notes]
        degree_names = SCALE_DEGREE_NAMES.get(scale_type, [])
        dr = display_root(root)

        position = 'all'
        for i, arg in enumerate(sys.argv):
            if arg == '--position' and i + 1 < len(sys.argv):
                position = sys.argv[i + 1]

        print(f"\n{dr} {scale_type.replace('-', ' ').title()}")
        print(f"Notes: {', '.join(display_notes)}")
        if degree_names:
            print(f"Degrees: {', '.join(degree_names)}")
        print()

        positions = get_pentatonic_positions(root, scale_type)

        if position == 'all':
            for pos in positions:
                print(render_position_full(pos, notes, scale_type, root))
                print()
        else:
            pos_num = int(position)
            if 1 <= pos_num <= len(positions):
                print(render_position_full(positions[pos_num - 1], notes, scale_type, root))
            else:
                print(f"Position {pos_num} not found (1-{len(positions)})")

    elif cmd == 'all-keys':
        scale_type = 'minor-pentatonic'
        if len(sys.argv) >= 3:
            scale_type = sys.argv[2]
        if scale_type not in SCALE_FORMULAS:
            print(f"Unknown scale type: {scale_type}")
            print(f"Available: {', '.join(SCALE_FORMULAS.keys())}")
            sys.exit(1)
        print(generate_all_keys(scale_type))

    elif cmd == 'exercise':
        if len(sys.argv) < 3:
            print("Usage: mirador-tab-generator exercise Am-pentatonic --position 1 --type legato")
            sys.exit(1)

        root, scale_type = parse_scale_arg(sys.argv[2])
        positions = get_pentatonic_positions(root, scale_type)

        pos_num = 1
        for i, arg in enumerate(sys.argv):
            if arg == '--position' and i + 1 < len(sys.argv):
                pos_num = int(sys.argv[i + 1])

        dr = display_root(root)
        if 1 <= pos_num <= len(positions):
            print(f"\n{dr} {scale_type.replace('-', ' ').title()} - Exercise")
            print()
            print(generate_legato_exercise(positions[pos_num - 1]))
        else:
            print(f"Position {pos_num} not found")

    elif cmd == 'fretboard':
        if len(sys.argv) < 3:
            print("Usage: mirador-tab-generator fretboard A")
            sys.exit(1)
        note = sys.argv[2]
        reverse_enharmonic = {v: k for k, v in ENHARMONIC.items()}
        note = reverse_enharmonic.get(note, note)
        if note not in CHROMATIC:
            print(f"Unknown note: {sys.argv[2]}. Use: {', '.join(CHROMATIC)}")
            sys.exit(1)
        print()
        print(show_note_on_fretboard(note))

    else:
        print(f"Unknown command: {cmd}")
        print(__doc__)
        sys.exit(1)

    print()


if __name__ == '__main__':
    main()
