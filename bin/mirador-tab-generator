#!/usr/bin/env python3
"""Generate verified ASCII guitar tablature from scale/chord definitions.

Uses a complete fretboard note map to produce accurate tabs that can be
paired with LLM-generated theory explanations and exercises.

Usage:
    mirador-tab-generator scale Am-pentatonic [--position 1-5|all]
    mirador-tab-generator scale Em-pentatonic --position 3
    mirador-tab-generator exercise Am-pentatonic --position 1 --type legato
    mirador-tab-generator chord Am7
    mirador-tab-generator fretboard A  # show all A notes on fretboard
"""

import sys

# Complete chromatic note sequence
CHROMATIC = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']

# Standard tuning open string notes
TUNING = ['E', 'A', 'D', 'G', 'B', 'E']  # low to high
TUNING_LABELS = ['E', 'A', 'D', 'G', 'B', 'e']  # display labels

# Scale formulas (intervals in semitones from root)
SCALE_FORMULAS = {
    'minor-pentatonic': [0, 3, 5, 7, 10],       # 1 b3 4 5 b7
    'major-pentatonic': [0, 2, 4, 7, 9],         # 1 2 3 5 6
    'natural-minor':    [0, 2, 3, 5, 7, 8, 10],  # 1 2 b3 4 5 b6 b7
    'natural-major':    [0, 2, 4, 5, 7, 9, 11],  # 1 2 3 4 5 6 7
    'blues':            [0, 3, 5, 6, 7, 10],      # 1 b3 4 b5 5 b7
    'dorian':           [0, 2, 3, 5, 7, 9, 10],  # 1 2 b3 4 5 6 b7
    'mixolydian':       [0, 2, 4, 5, 7, 9, 10],  # 1 2 3 4 5 6 b7
    'harmonic-minor':   [0, 2, 3, 5, 7, 8, 11],  # 1 2 b3 4 5 b6 7
}

SCALE_DEGREE_NAMES = {
    'minor-pentatonic': ['1', 'b3', '4', '5', 'b7'],
    'major-pentatonic': ['1', '2', '3', '5', '6'],
    'blues':            ['1', 'b3', '4', 'b5', '5', 'b7'],
}

# Chord formulas (intervals in semitones from root)
CHORD_FORMULAS = {
    'major':  [0, 4, 7],
    'minor':  [0, 3, 7],
    'dom7':   [0, 4, 7, 10],
    'min7':   [0, 3, 7, 10],
    'maj7':   [0, 4, 7, 11],
    'dim':    [0, 3, 6],
    'aug':    [0, 4, 8],
    'sus2':   [0, 2, 7],
    'sus4':   [0, 5, 7],
    'power':  [0, 7],
}


def note_at_fret(string_idx, fret):
    """Return the note name at a given string and fret."""
    open_note = TUNING[string_idx]
    open_idx = CHROMATIC.index(open_note)
    return CHROMATIC[(open_idx + fret) % 12]


def fret_for_note(string_idx, note, min_fret=0, max_fret=24):
    """Return all frets on a string where the given note appears."""
    open_note = TUNING[string_idx]
    open_idx = CHROMATIC.index(open_note)
    note_idx = CHROMATIC.index(note)
    frets = []
    for f in range(min_fret, max_fret + 1):
        if (open_idx + f) % 12 == note_idx:
            frets.append(f)
    return frets


def get_scale_notes(root, scale_type):
    """Return list of note names for a scale."""
    formula = SCALE_FORMULAS[scale_type]
    root_idx = CHROMATIC.index(root)
    return [CHROMATIC[(root_idx + interval) % 12] for interval in formula]


def get_pentatonic_positions(root, scale_type='minor-pentatonic'):
    """Compute all 5 pentatonic positions with 2 notes per string."""
    notes = get_scale_notes(root, scale_type)
    positions = []

    # Position 1 starts from the root on the low E string
    root_frets_e = fret_for_note(0, root, 0, 15)
    # Use the lowest root fret (open position is valid)
    start_fret = root_frets_e[0]

    # Build each position by finding 2 scale notes per string
    # within a 4-5 fret span
    for pos_num in range(5):
        pos_data = {'position': pos_num + 1, 'strings': []}

        if pos_num == 0:
            anchor = start_fret
        else:
            # Each position starts from the next scale degree on the low E
            # Find the next scale note on E string after previous position's start
            prev_anchor = positions[pos_num - 1]['strings'][0][0]['fret']
            candidates = []
            for note in notes:
                for f in fret_for_note(0, note, prev_anchor + 1, prev_anchor + 6):
                    candidates.append(f)
            candidates.sort()
            anchor = candidates[0] if candidates else prev_anchor + 2

        # For each string, find the 2 scale notes closest to the anchor
        min_fret = 24
        max_fret = 0
        for s in range(6):  # low E to high e
            string_notes = []
            for note in notes:
                for f in fret_for_note(s, note, max(0, anchor - 1), anchor + 5):
                    string_notes.append({'fret': f, 'note': note})
            # Sort by fret and take the 2 that form a clean box pattern
            string_notes.sort(key=lambda x: x['fret'])
            # Deduplicate
            seen = set()
            unique = []
            for sn in string_notes:
                if sn['fret'] not in seen:
                    seen.add(sn['fret'])
                    unique.append(sn)
            # Take first 2
            picked = unique[:2]
            pos_data['strings'].append(picked)
            for p in picked:
                min_fret = min(min_fret, p['fret'])
                max_fret = max(max_fret, p['fret'])

        pos_data['fret_range'] = (min_fret, max_fret)
        positions.append(pos_data)

    return positions


def render_tab(position_data, scale_notes=None, degree_names=None):
    """Render a single position as ASCII tab."""
    lines = []
    # Build from high e (index 5) to low E (index 0) for display
    tab_width = 30
    for s in reversed(range(6)):
        label = TUNING_LABELS[s]
        notes_on_string = position_data['strings'][s]
        # Build the tab line
        tab_content = '-' * tab_width
        # Place fret numbers
        note_strs = []
        for n in notes_on_string:
            fret_str = str(n['fret'])
            note_strs.append(f"{fret_str}({n['note']})")
        tab_line = '--' + '--'.join(str(n['fret']) for n in notes_on_string) + '--'
        tab_line = tab_line.ljust(20, '-')
        lines.append(f"{label}|{tab_line}|")

    return '\n'.join(lines)


def render_position_full(pos_data, scale_notes, scale_type):
    """Render a complete position with tab + note info."""
    fmin, fmax = pos_data['fret_range']
    output = []
    output.append(f"Position {pos_data['position']} (frets {fmin}-{fmax})")
    output.append("```")

    # Render tab high to low
    for s in reversed(range(6)):
        label = TUNING_LABELS[s]
        notes = pos_data['strings'][s]
        fret_strs = []
        for n in notes:
            fret_strs.append(str(n['fret']))
        # Pad for alignment
        content = '--'.join(f.rjust(2) for f in fret_strs)
        output.append(f"{label}|--{content}--|")

    output.append("```")

    # Note details
    output.append("Notes per string:")
    for s in range(6):
        label = TUNING_LABELS[s]
        notes = pos_data['strings'][s]
        note_info = ', '.join(f"fret {n['fret']}={n['note']}" for n in notes)
        output.append(f"  {label}: {note_info}")

    # Scale degrees
    degree_names = SCALE_DEGREE_NAMES.get(scale_type, [])
    if degree_names:
        output.append(f"Scale degrees: " + ', '.join(
            f"{n}({d})" for n, d in zip(scale_notes, degree_names)
        ))

    return '\n'.join(output)


def generate_legato_exercise(pos_data, bars=4):
    """Generate a legato exercise (hammer-ons/pull-offs) for a position."""
    output = []
    output.append(f"Legato Exercise - Position {pos_data['position']}")
    output.append("h = hammer-on, p = pull-off")
    output.append("```")

    # Ascending: low E to high e with hammer-ons
    # Descending: high e to low E with pull-offs
    asc_lines = {s: '' for s in range(6)}
    desc_lines = {s: '' for s in range(6)}

    for s in range(6):
        notes = pos_data['strings'][s]
        if len(notes) >= 2:
            low, high = notes[0]['fret'], notes[1]['fret']
            asc_lines[s] = f"{low}h{high}"
            desc_lines[s] = f"{high}p{low}"
        elif len(notes) == 1:
            asc_lines[s] = str(notes[0]['fret'])
            desc_lines[s] = str(notes[0]['fret'])

    # Bar 1-2: ascending
    for bar in range(min(2, bars)):
        for s in reversed(range(6)):
            label = TUNING_LABELS[s]
            if bar == 0:
                # Only current string plays
                pass
        # Simpler approach: one bar ascending, one descending, repeat
        pass

    # Render as ascending run then descending
    # Bar 1: ascending low E -> high e
    tab = {s: [] for s in range(6)}
    # Ascending
    for active_s in range(6):
        for s in range(6):
            if s == active_s:
                notes = pos_data['strings'][s]
                if len(notes) >= 2:
                    tab[s].append(f"{notes[0]['fret']}h{notes[1]['fret']}")
                else:
                    tab[s].append(str(notes[0]['fret']))
            else:
                width = len(tab[active_s][-1]) if tab[active_s] else 3
                tab[s].append('-' * width)

    # Add bar line
    for s in range(6):
        tab[s].append('|')

    # Descending
    for active_s in reversed(range(6)):
        for s in range(6):
            if s == active_s:
                notes = pos_data['strings'][s]
                if len(notes) >= 2:
                    tab[s].append(f"{notes[1]['fret']}p{notes[0]['fret']}")
                else:
                    tab[s].append(str(notes[0]['fret']))
            else:
                width = len(tab[active_s][-1]) if tab[active_s] else 3
                tab[s].append('-' * width)

    # Render
    for s in reversed(range(6)):
        label = TUNING_LABELS[s]
        content = '-'.join(tab[s])
        output.append(f"{label}|--{content}--|")

    output.append("```")
    return '\n'.join(output)


def show_note_on_fretboard(note, max_fret=15):
    """Show all occurrences of a note on the fretboard."""
    output = []
    output.append(f"All {note} notes on fretboard (frets 0-{max_fret}):")
    output.append("")

    # Header
    header = "    " + "  ".join(f"{f:>2}" for f in range(max_fret + 1))
    output.append(header)
    output.append("    " + "---" * (max_fret + 1))

    for s in reversed(range(6)):
        label = TUNING_LABELS[s]
        frets = fret_for_note(s, note, 0, max_fret)
        line = f"{label} | "
        for f in range(max_fret + 1):
            if f in frets:
                line += f" {note:>2}"
            else:
                line += "  ."
        output.append(line)

    return '\n'.join(output)


def parse_scale_arg(arg):
    """Parse 'Am-pentatonic' into ('A', 'minor-pentatonic')."""
    # Handle formats: Am-pentatonic, A-minor-pentatonic, Em-blues, etc.
    arg = arg.strip()

    # Check for shorthand: Am, Em, Gm etc.
    for i, c in enumerate(arg):
        if c == 'm' and (i + 1 >= len(arg) or arg[i + 1] == '-'):
            root = arg[:i]
            rest = arg[i + 1:].lstrip('-')
            if not rest:
                rest = 'minor-pentatonic'  # default
            elif rest == 'pentatonic':
                rest = 'minor-pentatonic'
            elif rest == 'blues':
                rest = 'blues'
            return root, rest

    # Check for major shorthand
    if '-' in arg:
        parts = arg.split('-', 1)
        root = parts[0]
        scale = parts[1]
        if scale == 'pentatonic':
            scale = 'major-pentatonic'
        elif scale == 'major':
            scale = 'natural-major'
        elif scale == 'minor':
            scale = 'natural-minor'
        return root, scale

    return arg, 'minor-pentatonic'


def main():
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(0)

    cmd = sys.argv[1]

    if cmd == 'scale':
        if len(sys.argv) < 3:
            print("Usage: mirador-tab-generator scale Am-pentatonic [--position 1-5|all]")
            sys.exit(1)

        root, scale_type = parse_scale_arg(sys.argv[2])
        if scale_type not in SCALE_FORMULAS:
            print(f"Unknown scale type: {scale_type}")
            print(f"Available: {', '.join(SCALE_FORMULAS.keys())}")
            sys.exit(1)

        notes = get_scale_notes(root, scale_type)
        degree_names = SCALE_DEGREE_NAMES.get(scale_type, [])

        # Parse position flag
        position = 'all'
        for i, arg in enumerate(sys.argv):
            if arg == '--position' and i + 1 < len(sys.argv):
                position = sys.argv[i + 1]

        print(f"\n{root} {scale_type.replace('-', ' ').title()}")
        print(f"Notes: {', '.join(notes)}")
        if degree_names:
            print(f"Degrees: {', '.join(degree_names)}")
        print()

        positions = get_pentatonic_positions(root, scale_type)

        if position == 'all':
            for pos in positions:
                print(render_position_full(pos, notes, scale_type))
                print()
        else:
            pos_num = int(position)
            if 1 <= pos_num <= len(positions):
                print(render_position_full(positions[pos_num - 1], notes, scale_type))
            else:
                print(f"Position {pos_num} not found (1-{len(positions)})")

    elif cmd == 'exercise':
        if len(sys.argv) < 3:
            print("Usage: mirador-tab-generator exercise Am-pentatonic --position 1 --type legato")
            sys.exit(1)

        root, scale_type = parse_scale_arg(sys.argv[2])
        notes = get_scale_notes(root, scale_type)
        positions = get_pentatonic_positions(root, scale_type)

        pos_num = 1
        for i, arg in enumerate(sys.argv):
            if arg == '--position' and i + 1 < len(sys.argv):
                pos_num = int(sys.argv[i + 1])

        if 1 <= pos_num <= len(positions):
            print(f"\n{root} {scale_type.replace('-', ' ').title()} - Exercise")
            print()
            print(generate_legato_exercise(positions[pos_num - 1]))
        else:
            print(f"Position {pos_num} not found")

    elif cmd == 'fretboard':
        if len(sys.argv) < 3:
            print("Usage: mirador-tab-generator fretboard A")
            sys.exit(1)
        note = sys.argv[2]
        if note not in CHROMATIC:
            print(f"Unknown note: {note}. Use: {', '.join(CHROMATIC)}")
            sys.exit(1)
        print()
        print(show_note_on_fretboard(note))

    else:
        print(f"Unknown command: {cmd}")
        print(__doc__)
        sys.exit(1)

    print()


if __name__ == '__main__':
    main()
