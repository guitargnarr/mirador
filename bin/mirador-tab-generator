#!/usr/bin/env python3
"""Generate verified ASCII guitar tablature from scale/chord definitions.

Uses a complete fretboard note map to produce accurate tabs that can be
paired with LLM-generated theory explanations and exercises.

Usage:
    mirador-tab-generator scale Am-pentatonic [--position 1-5|all]
    mirador-tab-generator scale Em-pentatonic --position 3
    mirador-tab-generator all-keys [minor-pentatonic|blues|major-pentatonic]
    mirador-tab-generator exercise Am-pentatonic --position 1 --type legato
    mirador-tab-generator fretboard A  # show all A notes on fretboard
"""

import sys

# Complete chromatic note sequence (sharps internally)
CHROMATIC = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']

# Enharmonic equivalents for display
ENHARMONIC = {
    'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb',
}

# Keys whose minor pentatonic scales use flats (Bb not A#, Eb not D#, etc.)
FLAT_KEYS = {'C', 'F', 'G', 'Bb', 'Eb', 'Ab', 'Db', 'Gb',
             'D#', 'G#', 'A#', 'C#'}
SHARP_KEYS = {'D', 'A', 'E', 'B', 'F#'}

# Standard tuning open string notes
TUNING = ['E', 'A', 'D', 'G', 'B', 'E']  # low to high
TUNING_LABELS = ['E', 'A', 'D', 'G', 'B', 'e']  # display labels

# Scale formulas (intervals in semitones from root)
SCALE_FORMULAS = {
    'minor-pentatonic': [0, 3, 5, 7, 10],
    'major-pentatonic': [0, 2, 4, 7, 9],
    'natural-minor':    [0, 2, 3, 5, 7, 8, 10],
    'natural-major':    [0, 2, 4, 5, 7, 9, 11],
    'blues':            [0, 3, 5, 6, 7, 10],
    'dorian':           [0, 2, 3, 5, 7, 9, 10],
    'mixolydian':       [0, 2, 4, 5, 7, 9, 10],
    'harmonic-minor':   [0, 2, 3, 5, 7, 8, 11],
}

SCALE_DEGREE_NAMES = {
    'minor-pentatonic': ['1', 'b3', '4', '5', 'b7'],
    'major-pentatonic': ['1', '2', '3', '5', '6'],
    'blues':            ['1', 'b3', '4', 'b5', '5', 'b7'],
    'natural-minor':    ['1', '2', 'b3', '4', '5', 'b6', 'b7'],
    'natural-major':    ['1', '2', '3', '4', '5', '6', '7'],
    'dorian':           ['1', '2', 'b3', '4', '5', '6', 'b7'],
    'mixolydian':       ['1', '2', '3', '4', '5', '6', 'b7'],
    'harmonic-minor':   ['1', '2', 'b3', '4', '5', 'b6', '7'],
}

# Chord formulas
CHORD_FORMULAS = {
    'major':  [0, 4, 7],
    'minor':  [0, 3, 7],
    'dom7':   [0, 4, 7, 10],
    'min7':   [0, 3, 7, 10],
    'maj7':   [0, 4, 7, 11],
    'dim':    [0, 3, 6],
    'aug':    [0, 4, 8],
    'sus2':   [0, 2, 7],
    'sus4':   [0, 5, 7],
    'power':  [0, 7],
}

ALL_ROOTS = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']


def display_note(note, root='C'):
    """Return the display name for a note, using flats or sharps based on key context."""
    if '#' not in note:
        return note
    if root in FLAT_KEYS or root in ENHARMONIC.values():
        return ENHARMONIC.get(note, note)
    return note


def display_root(root):
    """Return the conventional display name for a root note."""
    flat_display = {
        'C#': 'Db', 'D#': 'Eb', 'G#': 'Ab', 'A#': 'Bb',
    }
    return flat_display.get(root, root)


def note_at_fret(string_idx, fret):
    """Return the note name at a given string and fret."""
    open_note = TUNING[string_idx]
    open_idx = CHROMATIC.index(open_note)
    return CHROMATIC[(open_idx + fret) % 12]


def fret_for_note(string_idx, note, min_fret=0, max_fret=24):
    """Return all frets on a string where the given note appears."""
    open_note = TUNING[string_idx]
    open_idx = CHROMATIC.index(open_note)
    note_idx = CHROMATIC.index(note)
    frets = []
    for f in range(min_fret, max_fret + 1):
        if (open_idx + f) % 12 == note_idx:
            frets.append(f)
    return frets


def get_scale_notes(root, scale_type):
    """Return list of note names for a scale (internal sharp names)."""
    formula = SCALE_FORMULAS[scale_type]
    root_idx = CHROMATIC.index(root)
    return [CHROMATIC[(root_idx + interval) % 12] for interval in formula]


def _build_position(notes, anchor, pos_num, notes_per_string=2):
    """Build a single position from an anchor fret on the low E string."""
    pos_data = {'position': pos_num, 'strings': []}
    pos_min = 24
    pos_max = 0
    for s in range(6):
        string_notes = []
        for note in notes:
            for f in fret_for_note(s, note, max(0, anchor - 1), anchor + 4):
                string_notes.append({'fret': f, 'note': note})
        string_notes.sort(key=lambda x: x['fret'])
        seen = set()
        unique = []
        for sn in string_notes:
            if sn['fret'] not in seen:
                seen.add(sn['fret'])
                unique.append(sn)
        # Enforce notes-per-string limit
        picked = unique[:notes_per_string]
        pos_data['strings'].append(picked)
        for p in picked:
            pos_min = min(pos_min, p['fret'])
            pos_max = max(pos_max, p['fret'])
    pos_data['fret_range'] = (pos_min, pos_max)
    return pos_data


def get_scale_positions(root, scale_type='minor-pentatonic'):
    """Compute all 5 positions for any scale type.

    Pentatonic/blues: 2 notes per string (standard CAGED positions).
    7-note scales: 2-3 notes per string (3-note-per-string patterns).

    Returns list of position dicts, each with:
      - position: 1-5
      - strings: list of 6 lists, each containing {'fret': int, 'note': str} dicts
      - fret_range: (min_fret, max_fret)
    """
    notes = get_scale_notes(root, scale_type)
    num_scale_notes = len(notes)
    # Pentatonic (5) and blues (6) use 2 notes per string
    # 7-note scales use 3 notes per string
    nps = 2 if num_scale_notes <= 6 else 3
    positions = []

    root_frets_e = fret_for_note(0, root, 0, 15)
    start_fret = root_frets_e[0]

    for pos_num in range(5):
        if pos_num == 0:
            anchor = start_fret
        else:
            prev_low = positions[pos_num - 1]['strings'][0][0]['fret']
            candidates = []
            for note in notes:
                for f in fret_for_note(0, note, prev_low + 1, prev_low + 7):
                    candidates.append(f)
            candidates.sort()
            if not candidates:
                break
            anchor = candidates[0]

        pos_data = _build_position(notes, anchor, pos_num + 1, nps)

        # Dedupe: if identical frets to previous position, advance anchor
        if positions:
            prev = positions[-1]
            same = all(
                [n['fret'] for n in prev['strings'][s]] == [n['fret'] for n in pos_data['strings'][s]]
                for s in range(6)
            )
            if same:
                candidates2 = []
                for note in notes:
                    for f in fret_for_note(0, note, anchor + 1, anchor + 8):
                        candidates2.append(f)
                candidates2.sort()
                if candidates2:
                    anchor = candidates2[0]
                    pos_data = _build_position(notes, anchor, pos_num + 1, nps)

        positions.append(pos_data)

    return positions


def _render_columns(lines_dict, max_cols=0):
    """Render column data into tab lines, wrapping at max_cols if set.

    lines_dict: {string_idx: [col_str, col_str, ...]}
    max_cols: max columns per line (0 = no limit)
    Returns formatted tab string.
    """
    total_cols = len(lines_dict[0])
    if total_cols == 0:
        return ""

    if max_cols <= 0:
        max_cols = total_cols

    # Build the first (full) chunk to get the target line width
    first_content = '--'.join(lines_dict[0][0:min(max_cols, total_cols)])
    target_width = len(f"  e|--{first_content}--|")

    chunks = []
    for start in range(0, total_cols, max_cols):
        end = min(start + max_cols, total_cols)
        chunk_lines = []
        for s in reversed(range(6)):
            label = TUNING_LABELS[s]
            content = '--'.join(lines_dict[s][start:end])
            line = f"  {label}|--{content}--|"
            # Pad shorter chunks with dashes to match full width
            if len(line) < target_width:
                # Insert dashes before the closing --|
                pad = target_width - len(line)
                line = f"  {label}|--{content}{'-' * pad}--|"
            chunk_lines.append(line)
        chunks.append('\n'.join(chunk_lines))

    return '\n\n'.join(chunks)


def render_tab_sequential(pos_data, root='C', max_cols=0):
    """Render tab as an ascending scale run - notes play left to right, one string at a time.

    This is how you actually play a scale: low E first, then A, D, G, B, e.
    Each string's notes appear at the correct horizontal position in the sequence.
    max_cols: wrap after this many note columns (0 = no wrap).
    """
    # Build the sequential note list: string 0 notes, string 1 notes, etc.
    all_events = []  # list of (string_idx, fret, note)
    for s in range(6):
        for n in pos_data['strings'][s]:
            all_events.append((s, n['fret'], n['note']))

    if not all_events:
        return ""

    # Build each string's line
    lines = {s: [] for s in range(6)}

    for col_idx, (active_s, fret, note) in enumerate(all_events):
        fret_str = str(fret)
        for s in range(6):
            if s == active_s:
                lines[s].append(fret_str.rjust(2))
            else:
                lines[s].append('--')

    return _render_columns(lines, max_cols)


def render_position_full(pos_data, scale_notes, scale_type, root='C'):
    """Render a complete position with sequential tab + note info."""
    fmin, fmax = pos_data['fret_range']
    output = []
    output.append(f"Position {pos_data['position']} (frets {fmin}-{fmax})")

    output.append(render_tab_sequential(pos_data, root))

    # Note legend per string
    output.append("  Notes:")
    for s in range(6):
        label = TUNING_LABELS[s]
        notes = pos_data['strings'][s]
        if notes:
            note_info = ', '.join(
                f"{n['fret']}={display_note(n['note'], root)}" for n in notes
            )
            output.append(f"    {label}: {note_info}")

    degree_names = SCALE_DEGREE_NAMES.get(scale_type, [])
    if degree_names:
        output.append("  Degrees: " + ', '.join(
            f"{display_note(n, root)}({d})" for n, d in zip(scale_notes, degree_names)
        ))

    return '\n'.join(output)


def render_tab_compact(pos_data, root='C'):
    """Compact sequential tab for all-keys output."""
    return render_tab_sequential(pos_data, root)


def flatten_position(pos_data):
    """Get all notes in ascending playing order as (string_idx, fret) tuples."""
    notes = []
    for s in range(6):
        for n in pos_data['strings'][s]:
            notes.append((s, n['fret']))
    return notes


def render_exercise_tab(events, label_prefix="", max_cols=0):
    """Render a list of (string_idx, fret_text) events as sequential tab.

    fret_text can be a plain number string or include technique marks like 'D5' or '>8'.
    max_cols: wrap after this many note columns (0 = no wrap).
    """
    if not events:
        return ""
    lines = {s: [] for s in range(6)}
    for (active_s, text) in events:
        tw = max(len(str(text)), 2)
        for s in range(6):
            if s == active_s:
                lines[s].append(str(text).rjust(tw))
            elif active_s == -1:
                # Bar line
                lines[s].append(str(text).center(tw))
            else:
                lines[s].append('-' * tw)

    return _render_columns(lines, max_cols)


def exercise_ascending(pos_data):
    """Straight ascending run through all notes in position."""
    flat = flatten_position(pos_data)
    return "Ascending Run", flat


def exercise_descending(pos_data):
    """Descending run from high e back to low E."""
    flat = flatten_position(pos_data)
    return "Descending Run", list(reversed(flat))


def exercise_legato(pos_data):
    """Hammer-on ascending, pull-off descending."""
    asc = []
    for s in range(6):
        notes = pos_data['strings'][s]
        if len(notes) >= 2:
            asc.append((s, f"{notes[0]['fret']}h{notes[1]['fret']}"))
        elif notes:
            asc.append((s, str(notes[0]['fret'])))
    desc = []
    for s in reversed(range(6)):
        notes = pos_data['strings'][s]
        if len(notes) >= 2:
            desc.append((s, f"{notes[1]['fret']}p{notes[0]['fret']}"))
        elif notes:
            desc.append((s, str(notes[0]['fret'])))
    events = asc + [(-1, '|')] + desc
    return "Legato (h=hammer-on, p=pull-off)", events


def exercise_sequence3(pos_data):
    """Sequence in groups of 3: play 3 notes, step back 1, repeat."""
    flat = flatten_position(pos_data)
    events = []
    i = 0
    while i + 2 < len(flat):
        events.extend(flat[i:i + 3])
        i += 1
    if not events:
        events = flat
    return "Sequence in 3s", events


def exercise_sequence4(pos_data):
    """Sequence in groups of 4: play 4 notes, step back 2, repeat."""
    flat = flatten_position(pos_data)
    events = []
    i = 0
    while i + 3 < len(flat):
        events.extend(flat[i:i + 4])
        i += 2
    if not events:
        events = flat
    return "Sequence in 4s", events


def exercise_string_skip(pos_data):
    """String skipping: alternate low and high strings (E-G, A-B, D-e)."""
    pairs = [(0, 3), (1, 4), (2, 5)]  # E-G, A-B, D-e
    events = []
    for lo, hi in pairs:
        for n in pos_data['strings'][lo]:
            events.append((lo, n['fret']))
        for n in pos_data['strings'][hi]:
            events.append((hi, n['fret']))
    return "String Skipping (E-G, A-B, D-e)", events


def exercise_alternate_picking(pos_data):
    """Ascending run with down/up picking marks."""
    flat = flatten_position(pos_data)
    events = []
    for i, (s, fret) in enumerate(flat):
        pick = 'D' if i % 2 == 0 else 'U'
        events.append((s, f"{pick}{fret}"))
    return "Alternate Picking (D=down, U=up)", events


def exercise_triplet(pos_data):
    """Triplet grouping: accent every 3rd note with >."""
    flat = flatten_position(pos_data)
    events = []
    for i, (s, fret) in enumerate(flat):
        if i % 3 == 0:
            events.append((s, f">{fret}"))
        else:
            events.append((s, str(fret)))
    return "Triplet Grouping (> = accent)", events


EXERCISE_TYPES = {
    'ascending': exercise_ascending,
    'descending': exercise_descending,
    'legato': exercise_legato,
    'sequence3': exercise_sequence3,
    'sequence4': exercise_sequence4,
    'string-skip': exercise_string_skip,
    'alternate': exercise_alternate_picking,
    'triplet': exercise_triplet,
}


# ── Chord Voicing System ──────────────────────────────────────────────

# Barre chord shapes: (root_string_idx, offsets_from_barre_fret)
# -1 = muted string
BARRE_SHAPES = {
    'major_E':  (0, [0, 2, 2, 1, 0, 0]),
    'major_A':  (1, [-1, 0, 2, 2, 2, 0]),
    'minor_E':  (0, [0, 2, 2, 0, 0, 0]),
    'minor_A':  (1, [-1, 0, 2, 2, 1, 0]),
    'dom7_E':   (0, [0, 2, 0, 1, 0, 0]),
    'dom7_A':   (1, [-1, 0, 2, 0, 2, 0]),
    'min7_E':   (0, [0, 2, 0, 0, 0, 0]),
    'min7_A':   (1, [-1, 0, 2, 0, 1, 0]),
    'maj7_A':   (1, [-1, 0, 2, 1, 2, 0]),
    'dim_A':    (1, [-1, 0, 1, 2, 1, -1]),
    'aug_E':    (0, [0, 3, 2, 1, 1, 0]),
    'sus2_A':   (1, [-1, 0, 2, 2, 0, 0]),
    'sus4_E':   (0, [0, 2, 2, 2, 0, 0]),
    'power_E':  (0, [0, 2, 2, -1, -1, -1]),
    'power_A':  (1, [-1, 0, 2, 2, -1, -1]),
}

# Default shape key per chord type
CHORD_TYPE_SHAPES = {
    'major': 'major_E', 'minor': 'minor_E', 'dom7': 'dom7_E',
    'min7': 'min7_E', 'maj7': 'maj7_A', 'dim': 'dim_A',
    'aug': 'aug_E', 'sus2': 'sus2_A', 'sus4': 'sus4_E',
    'power': 'power_E',
}

# Common open chord voicings: (root, chord_type) -> [frets], -1 = muted
OPEN_CHORDS = {
    ('C', 'major'):  [-1, 3, 2, 0, 1, 0],
    ('C', 'dom7'):   [-1, 3, 2, 3, 1, 0],
    ('D', 'major'):  [-1, -1, 0, 2, 3, 2],
    ('D', 'minor'):  [-1, -1, 0, 2, 3, 1],
    ('D', 'dom7'):   [-1, -1, 0, 2, 1, 2],
    ('E', 'major'):  [0, 2, 2, 1, 0, 0],
    ('E', 'minor'):  [0, 2, 2, 0, 0, 0],
    ('E', 'dom7'):   [0, 2, 0, 1, 0, 0],
    ('E', 'min7'):   [0, 2, 0, 0, 0, 0],
    ('F', 'major'):  [1, 3, 3, 2, 1, 1],
    ('G', 'major'):  [3, 2, 0, 0, 0, 3],
    ('G', 'dom7'):   [3, 2, 0, 0, 0, 1],
    ('A', 'major'):  [-1, 0, 2, 2, 2, 0],
    ('A', 'minor'):  [-1, 0, 2, 2, 1, 0],
    ('A', 'dom7'):   [-1, 0, 2, 0, 2, 0],
    ('A', 'min7'):   [-1, 0, 2, 0, 1, 0],
    ('B', 'minor'):  [-1, 2, 4, 4, 3, 2],
    ('B', 'dom7'):   [-1, 2, 1, 2, 0, 2],
}

# Diatonic chord qualities for companion chord generation
# Maps parent scale type -> list of (degree_index, chord_quality)
DIATONIC_CHORDS = {
    'natural-minor': [
        (0, 'minor'), (1, 'dim'), (2, 'major'), (3, 'minor'),
        (4, 'minor'), (5, 'major'), (6, 'major'),
    ],
    'natural-major': [
        (0, 'major'), (1, 'minor'), (2, 'minor'), (3, 'major'),
        (4, 'major'), (5, 'minor'), (6, 'dim'),
    ],
}

# Which diatonic degrees to show as companion chords per scale type
COMPANION_DEGREES = {
    'minor-pentatonic': [0, 2, 3, 4, 6],   # i, III, iv, v, VII
    'major-pentatonic': [0, 1, 3, 4, 5],    # I, ii, IV, V, vi
    'blues':            None,                 # special: I7, IV7, V7
    'natural-minor':    [0, 2, 3, 4, 5, 6],  # i, III, iv, v, VI, VII
    'natural-major':    [0, 1, 3, 4, 5],      # I, ii, IV, V, vi
    'dorian':           [0, 2, 3, 6],          # i, III, IV, VII
    'mixolydian':       [0, 3, 4, 6],          # I, IV, v, VII
    'harmonic-minor':   [0, 3, 4, 5],          # i, iv, V, VI
}

# Parent scale for diatonic chord lookup
SCALE_PARENT = {
    'minor-pentatonic': 'natural-minor',
    'major-pentatonic': 'natural-major',
    'blues':            'natural-minor',
    'natural-minor':    'natural-minor',
    'natural-major':    'natural-major',
    'dorian':           'natural-minor',
    'mixolydian':       'natural-major',
    'harmonic-minor':   'natural-minor',
}


def get_chord_voicing(root, chord_type='minor'):
    """Return a 6-element list of fret numbers for a chord voicing.

    Returns list where -1 = muted string. Checks open chords first,
    then transposes barre shapes.
    """
    # Check open chord overrides first
    key = (root, chord_type)
    if key in OPEN_CHORDS:
        return OPEN_CHORDS[key]

    # Transpose barre shape
    shape_key = CHORD_TYPE_SHAPES.get(chord_type)
    if not shape_key or shape_key not in BARRE_SHAPES:
        return [-1, -1, -1, -1, -1, -1]

    root_string, offsets = BARRE_SHAPES[shape_key]
    # Find the barre fret: where root note falls on the root string
    open_note = TUNING[root_string]
    open_idx = CHROMATIC.index(open_note)
    root_idx = CHROMATIC.index(root)
    barre = (root_idx - open_idx) % 12

    voicing = []
    for s in range(6):
        if offsets[s] == -1:
            voicing.append(-1)
        else:
            voicing.append(barre + offsets[s])
    return voicing


def get_companion_chords(root, scale_type='minor-pentatonic'):
    """Return companion chords for a scale as [(name, voicing), ...]."""
    # Special case: blues uses I7 IV7 V7
    if scale_type == 'blues' or COMPANION_DEGREES.get(scale_type) is None:
        parent = SCALE_PARENT.get(scale_type, 'natural-minor')
        parent_notes = get_scale_notes(root, parent)
        chords = []
        for degree in [0, 3, 4]:  # I, IV, V
            chord_root = parent_notes[degree]
            dr = display_note(chord_root, root)
            voicing = get_chord_voicing(chord_root, 'dom7')
            chords.append((f"{dr}7", voicing))
        return chords

    parent = SCALE_PARENT.get(scale_type, 'natural-minor')
    parent_notes = get_scale_notes(root, parent)
    diatonic = DIATONIC_CHORDS.get(parent, [])
    degrees = COMPANION_DEGREES.get(scale_type, [0, 2, 3, 4, 6])

    chords = []
    for deg in degrees:
        if deg >= len(parent_notes) or deg >= len(diatonic):
            continue
        chord_root = parent_notes[diatonic[deg][0]]
        chord_type = diatonic[deg][1]
        dr = display_note(chord_root, root)
        suffix = '' if chord_type == 'major' else 'm' if chord_type == 'minor' else 'dim'
        voicing = get_chord_voicing(chord_root, chord_type)
        chords.append((f"{dr}{suffix}", voicing))
    return chords


def render_chord_tab(chord_list):
    """Render chords side-by-side as vertical tab stacks.

    chord_list: [(name, voicing), ...] where voicing is 6-element list.
    """
    if not chord_list:
        return ""
    # Column width based on longest chord name
    col_w = max(len(name) for name, _ in chord_list) + 4

    output = []
    # Header line with chord names
    header = '  ' + ''.join(name.center(col_w) for name, _ in chord_list)
    output.append(header)

    for s in reversed(range(6)):
        label = TUNING_LABELS[s]
        parts = []
        for name, voicing in chord_list:
            fret = voicing[s]
            if fret == -1:
                fret_str = 'X'
            else:
                fret_str = str(fret)
            cell = f"|--{fret_str}--|"
            parts.append(cell.center(col_w))
        output.append(f"  {label}{''.join(parts)}")
    return '\n'.join(output)


def generate_exercise(pos_data, exercise_type='legato'):
    """Generate a named exercise for a position."""
    if exercise_type not in EXERCISE_TYPES:
        return f"Unknown exercise type: {exercise_type}\nAvailable: {', '.join(EXERCISE_TYPES.keys())}"
    gen_fn = EXERCISE_TYPES[exercise_type]
    name, events = gen_fn(pos_data)
    output = [f"{name} - Position {pos_data['position']}"]
    output.append(render_exercise_tab(events))
    return '\n'.join(output)


def show_note_on_fretboard(note, max_fret=15):
    """Show all occurrences of a note on the fretboard."""
    output = []
    dn = display_note(note)
    output.append(f"All {dn} notes on fretboard (frets 0-{max_fret}):")
    output.append("")

    header = "      " + "  ".join(f"{f:>2}" for f in range(max_fret + 1))
    output.append(header)
    output.append("      " + "---" * (max_fret + 1))

    for s in reversed(range(6)):
        label = TUNING_LABELS[s]
        frets = fret_for_note(s, note, 0, max_fret)
        line = f"  {label} | "
        for f in range(max_fret + 1):
            if f in frets:
                line += f" {dn:>2}"
            else:
                line += "  ."
        output.append(line)

    return '\n'.join(output)


def generate_all_keys(scale_type='minor-pentatonic'):
    """Generate all 5 positions for all 12 keys."""
    output = []
    output.append(f"{'=' * 70}")
    output.append(f"  ALL 12 KEYS - {scale_type.replace('-', ' ').title()}")
    output.append(f"  5 positions per key, 60 total patterns")
    output.append(f"{'=' * 70}")

    degree_names = SCALE_DEGREE_NAMES.get(scale_type, [])

    for root in ALL_ROOTS:
        dr = display_root(root)
        notes = get_scale_notes(root, scale_type)
        display_notes = [display_note(n, root) for n in notes]

        output.append("")
        output.append(f"{'─' * 70}")
        if scale_type == 'minor-pentatonic':
            output.append(f"  {dr} Minor Pentatonic")
        elif scale_type == 'major-pentatonic':
            output.append(f"  {dr} Major Pentatonic")
        elif scale_type == 'blues':
            output.append(f"  {dr} Blues")
        else:
            output.append(f"  {dr} {scale_type.replace('-', ' ').title()}")

        output.append(f"  Notes: {', '.join(display_notes)}")
        if degree_names:
            output.append(f"  Degrees: {', '.join(degree_names)}")
        output.append(f"{'─' * 70}")

        positions = get_scale_positions(root, scale_type)
        for pos in positions:
            fmin, fmax = pos['fret_range']
            output.append(f"\n  Position {pos['position']} (frets {fmin}-{fmax})")
            output.append(render_tab_compact(pos, root))

            # Note legend on one line
            parts = []
            for s in range(6):
                label = TUNING_LABELS[s]
                for n in pos['strings'][s]:
                    parts.append(f"{label}:{n['fret']}={display_note(n['note'], root)}")
            output.append(f"  {' | '.join(parts)}")

    output.append("")
    output.append(f"{'=' * 70}")
    output.append(f"  Generated {len(ALL_ROOTS)} keys x 5 positions = 60 patterns")
    output.append(f"{'=' * 70}")

    return '\n'.join(output)


def parse_scale_arg(arg):
    """Parse 'Am-pentatonic' into ('A', 'minor-pentatonic')."""
    arg = arg.strip()
    reverse_enharmonic = {v: k for k, v in ENHARMONIC.items()}

    for i, c in enumerate(arg):
        if c == 'm' and (i + 1 >= len(arg) or arg[i + 1] == '-'):
            root = arg[:i]
            root = reverse_enharmonic.get(root, root)
            if root not in CHROMATIC:
                print(f"Unknown root: {arg[:i]}. Use: {', '.join(CHROMATIC)}")
                sys.exit(1)
            rest = arg[i + 1:].lstrip('-')
            if not rest:
                rest = 'minor-pentatonic'
            elif rest == 'pentatonic':
                rest = 'minor-pentatonic'
            elif rest == 'blues':
                rest = 'blues'
            return root, rest

    if '-' in arg:
        parts = arg.split('-', 1)
        root = parts[0]
        root = reverse_enharmonic.get(root, root)
        scale = parts[1]
        if scale == 'pentatonic':
            scale = 'major-pentatonic'
        elif scale == 'major':
            scale = 'natural-major'
        elif scale == 'minor':
            scale = 'natural-minor'
        return root, scale

    return arg, 'minor-pentatonic'


def main():
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(0)

    cmd = sys.argv[1]

    if cmd == 'scale':
        if len(sys.argv) < 3:
            print("Usage: mirador-tab-generator scale Am-pentatonic [--position 1-5|all]")
            sys.exit(1)

        root, scale_type = parse_scale_arg(sys.argv[2])
        if scale_type not in SCALE_FORMULAS:
            print(f"Unknown scale type: {scale_type}")
            print(f"Available: {', '.join(SCALE_FORMULAS.keys())}")
            sys.exit(1)

        notes = get_scale_notes(root, scale_type)
        display_notes = [display_note(n, root) for n in notes]
        degree_names = SCALE_DEGREE_NAMES.get(scale_type, [])
        dr = display_root(root)

        position = 'all'
        for i, arg in enumerate(sys.argv):
            if arg == '--position' and i + 1 < len(sys.argv):
                position = sys.argv[i + 1]

        print(f"\n{dr} {scale_type.replace('-', ' ').title()}")
        print(f"Notes: {', '.join(display_notes)}")
        if degree_names:
            print(f"Degrees: {', '.join(degree_names)}")
        print()

        positions = get_scale_positions(root, scale_type)

        if position == 'all':
            for pos in positions:
                print(render_position_full(pos, notes, scale_type, root))
                print()
        else:
            pos_num = int(position)
            if 1 <= pos_num <= len(positions):
                print(render_position_full(positions[pos_num - 1], notes, scale_type, root))
            else:
                print(f"Position {pos_num} not found (1-{len(positions)})")

    elif cmd == 'all-keys':
        scale_type = 'minor-pentatonic'
        if len(sys.argv) >= 3:
            scale_type = sys.argv[2]
        if scale_type not in SCALE_FORMULAS:
            print(f"Unknown scale type: {scale_type}")
            print(f"Available: {', '.join(SCALE_FORMULAS.keys())}")
            sys.exit(1)
        print(generate_all_keys(scale_type))

    elif cmd == 'exercise':
        if len(sys.argv) < 3:
            print("Usage: mirador-tab-generator exercise Am-pentatonic --position 1 --type legato")
            print(f"Types: {', '.join(EXERCISE_TYPES.keys())}, all")
            sys.exit(1)

        root, scale_type = parse_scale_arg(sys.argv[2])
        positions = get_scale_positions(root, scale_type)

        pos_num = 1
        ex_type = 'legato'
        for i, arg in enumerate(sys.argv):
            if arg == '--position' and i + 1 < len(sys.argv):
                pos_num = int(sys.argv[i + 1])
            if arg == '--type' and i + 1 < len(sys.argv):
                ex_type = sys.argv[i + 1]

        dr = display_root(root)
        if 1 <= pos_num <= len(positions):
            pos = positions[pos_num - 1]
            print(f"\n{dr} {scale_type.replace('-', ' ').title()} - Position {pos_num}")
            print()
            if ex_type == 'all':
                for etype in EXERCISE_TYPES:
                    print(generate_exercise(pos, etype))
                    print()
            else:
                print(generate_exercise(pos, ex_type))
        else:
            print(f"Position {pos_num} not found")

    elif cmd == 'chord':
        if len(sys.argv) < 3:
            print("Usage: mirador-tab-generator chord Am-pentatonic")
            print("  Shows companion chords for a scale/key")
            sys.exit(1)
        root, scale_type = parse_scale_arg(sys.argv[2])
        dr = display_root(root)
        chords = get_companion_chords(root, scale_type)
        print(f"\nCompanion Chords for {dr} {scale_type.replace('-', ' ').title()}")
        print(f"Play these chords over your {dr} {scale_type.replace('-', ' ').title()} exercises:\n")
        print(render_chord_tab(chords))
        progression = ' - '.join(name for name, _ in chords)
        print(f"\n  Progression: {progression}")

    elif cmd == 'fretboard':
        if len(sys.argv) < 3:
            print("Usage: mirador-tab-generator fretboard A")
            sys.exit(1)
        note = sys.argv[2]
        reverse_enharmonic = {v: k for k, v in ENHARMONIC.items()}
        note = reverse_enharmonic.get(note, note)
        if note not in CHROMATIC:
            print(f"Unknown note: {sys.argv[2]}. Use: {', '.join(CHROMATIC)}")
            sys.exit(1)
        print()
        print(show_note_on_fretboard(note))

    else:
        print(f"Unknown command: {cmd}")
        print(__doc__)
        sys.exit(1)

    print()


if __name__ == '__main__':
    main()
